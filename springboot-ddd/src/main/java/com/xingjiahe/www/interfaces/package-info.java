package com.xingjiahe.www.interfaces;
/**
 * 接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，
 * 并将信息传递给应用层。
 * dto：数据传输对象，类似于领域层的Vo，但是不含任何业务逻辑
 * 装配器模式：实现DTO和领域对象之间的相互转换，数据交换，
 * 因此Assembler几乎总是和DTO一起出现
 * 门面模式：Facade的用意在于为远程的客户端提供粗粒度的接口，
 * 他的主要工作是将一个用户的请求委派给一个或多个Service进行处理，
 * 也就是我们所说的Controller
 * 无论我们代码结构如何规划，也并非一成不变，应该从实际出发，去思考划分结构的意义。
 * 此例子是对于微服务+DDD反应到实际开发，
 * 代码的结构设计上的一种初步的思考与探索,一个样板工程，
 * 不应该成为我们对实际DDD思考与设计的限制，本例仅供参考。
 * 微服务架构设计，一个微服务应该就是一个可单独部署，可运行的应用，也就是微服务最小的运行单元。
 * 　　微服务本身内部高度内聚，微服务与微服务之间低耦合。
 * 　　首先对于应用划分上，就应该想清楚每个微服务的职责，每个微服务服务内部建立起自己的依赖，完成自己的职责和业务。
 * 　　微服务与微服务之间交互通过HTTP或RPC接口调用，降低微服务之间代码实现和业务的耦合。
 * 　　微服务的实现不应该受限某程序语言(或Java，或Go，或Python)，不应该受限于某框架(或SpringCloud，或Dubbo，或各种RPC框架等等)。
 * 　　我的代码结构是对于一个微服务本身(即应用)划分的，领域是对于微服务内部本身而言的，即这个微服务涉及哪些领域。
 * 　　首先从大的方向去划分每一个微服务，然后再从每一个微服务确定所包含的领域，领域的边界，等等。
 * 　　比如划分了一个 认证授权服务，那么 领域可能有 用户，权限；实体可能有角色，资源等等。领域行为有授权登录，用户退出，授权等等。
 * 　　不要被框架和结构本身所限制！
 * <p>
 * DDD 是什么？
 * DDD（Domain-Driven Design 领域驱动设计）是由Eric Evans最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。
 * 整个过程大概是这样的，开发团队和领域专家一起通过
 * 通用语言(Ubiquitous Language)去理解和消化领域知识
 * ，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），
 * 并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。
 *
 *DDD 开发目标
 * 依靠领域驱动设计的设计思想，通过事件风暴建立领域模型，合理划分领域逻辑和物理边界，建立领域对象及服务矩阵和服务架构图，定义符合DDD分层架构思想的代码结构模型，保证业务模型与代码模型的一致性。通过上述设计思想、方法和过程，指导团队按照DDD设计思想完成微服务设计和开发。
 * 1、拒绝泥球小单体、拒绝污染功能与服务、拒绝一加功能排期一个月
 * 2、架构出高可用极易符合互联网高速迭代的应用服务
 * 3、物料化、组装化、可编排的服务，提高人效
 *
 * 为什么要用“领域驱动设计”？
 * “领域驱动设计”相比于mvc/soa的优势？
 * 所谓的领域， 其实就是 一个个的业务子系统。
 * 领域驱动设计， 其实就是 “业务驱动设计”
 * mvc/soa结构的项目， 业务逻辑集中写在了service层， 当业务变更了， 就得修改service代码， 如果原来的业务逻辑较为复杂，代码也会复杂， 修改起来是一件很痛苦的事情。
 * <p>
 * 领域驱动设计：
 * 用application代替了mvc/soa的service层， application不涉及到具体的业务逻辑， 只涉及到业务的流程。修改业务逻辑， 只需要到对应的领域对象中修改即可； 添加新的业务流程， 只需要调用相关的领域对象即可。
 * <p>
 * 领域对象代码包含：
 * 实体(Entity)、持久层访问接口、 service(用来联合多个实体对象，以及具体的业务逻辑)
 * <p>
 * 也就是说， “领域对象”包含业务逻辑， 和自己紧密相关的业务逻辑， 把mvc/soa的service层的复杂度/业务逻辑 拆分到了具体的一个个领域对象中，
 */
